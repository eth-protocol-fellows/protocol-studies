# EIP-7702: Set EOA code

> :warning: This article is a [stub](https://en.wikipedia.org/wiki/Wikipedia:Stub), help the wiki by [contributing](/contributing.md) and expanding it.

[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)  is a proposal aimed at enhancing Ethereum's account abstraction capabilities. Account abstraction allows for more flexible and programmable account management, enabling features such as multi-signature wallets, social recovery, and gasless transactions. This proposal seeks to improve the user experience and security by decoupling the logic of transaction validation from the underlying account model.

The primary goal of EIP-7702 is to introduce a standardized framework that allows developers to create custom transaction validation logic. A new transaction type (Type 4) is introduced to secure and allow user-friendly wallet solutions, as well as innovative use cases that were previously not possible with the traditional account model. By abstracting the account logic, EIP-7702 aims to reduce the complexity of smart contract interactions and lower the barrier to entry for new users.

With this feature, users can set their address to be represented by a code of an existing smart contract. Type 4 transaction allows address owners to sign an authorization that sets their address to mimic a chosen smart contract.
With this EIP, users can opt in to programmable wallets that allow new features like transaction bundling, gasless transacting and custom asset access for alternative recovery schemes. It's another step towards [account abstraction](https://ethereum.org/en/roadmap/account-abstraction/) that improves user experience and security when interacting with Ethereum.

Review `@lightclient's` technical deep dive:

<!-- markdownlint-disable-next-line MD033 -->
<iframe width="560" height="315" src="https://www.youtube.com/embed/_k5fKlKBWV4?si=Y4DehqLu5fpT7-a3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Rationale

It is also precedeed by ERC-4337, the account abstraction standard.
Given the existence of ERC-4337 you might ask why is EIP-7702 required. The account abstraction has an entirely different goal while this proposal's main goal is to give EOAs some temporary programmability.

The benefits include of programmability are the following:
- Transaction batching
- Transaction Sponsorship
- Privilege de-escalation and Session keys 
- Social Recovery
- And the list is endless...

Historically EIP-7702 is a simpler alternative to the proposed EIP-3074 which would've added AUTH and AUTHCALL opcodes.  
The main reason for this limited EOA is to push users towards Smart Wallets as describe in [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) and create a unified interface from the dApp perspective.  
7702 is a step towards native Account Abstraction and is fully compatible with Account Abstraction, meaning you can delegate via 7702 to a Smart Wallet.

## Technical Details

In the ethereum account model the difference between contract accounts and externally owned accounts is that EOAs do not have code that can be executed onchain, practically the code field is set to null.
This proposal adds a new [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) compatible transaction call to set code field for an EOA temporarily.  
The `TransactionType` type is called `SET_CODE_TX_TYPE` with value=4.  
The `TransactionPayload` object defined as a RLP serialized tuple with the following fields:
`chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, value, data, access_list, authorization_list, signature_y_parity, signature_r, signature_s`.  
The authorization list is defined as non-empty list of `chain_id, address, nonce, y_parity, r, s` tuples, where the `address` refers to the delegated code's address, the `chain_id` can be set to a valid chain's id or to 0 and the `nonce` has to equal to the EOA for replay protection.
`y_parity, r, s` is the signature of the EOA.    
This list can be submitted by anyone meaning the `tx.origin` doesn't have to be the EOA owner as long as it contains a valid signature. Setting the chain id to zero allows the resubmission of the transaction on any chain, given that the nonce values match.  
The `ReceiptPayload` is defined as the `status, cumulative_transaction_gas_used, logs_bloom, logs` tuple in RLP seralized form.

You can learn more about RLP encoding in [this section](https://epf.wiki/#/wiki/EL/RLP).

When such a set code transaction is submitted the following basic steps happen for each tuple in the `authorization_list`.
1. Alongside basic validation(e.g. auth.chain_id < 2^256, auth.nonce < 2^64, etc.) the chain id is verified that it is either 0 or the current chain's id.
2. Then the address of the authority is recovered from the signature and the payload.
3. The code of the authority is either set to `0xef0100 || address` if the `address` is not `0x0000000000000000000000000000000000000000`, otherwise the EOA's code is cleared and is set to the hash of an empty address (`0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`). This acts as a revocation mechanism
4. The delegation address is marked as warm address.

For each authorization tuple the nonce of the EOA is increased by 1, meaning every tuple has to calculate their nonce value based on their position in the list.  
This simplified execution steps skipped important steps, a more detailed execution can be found at the [Behavior section](https://eips.ethereum.org/EIPS/eip-7702#behavior) of the EIP.


### Creation by template

Due to space optimization the traditional `initCode` is replaced by a "code pointer" and the initialization happens during a regular call.
[EIP-3607](https://eips.ethereum.org/EIPS/eip-3607) specifies that an account with deployed code cannot originate transactions.  
To work around this the `code` field gets populated with the address of the delegated contract and a prefix which is 23 bytes in total.  
The prefix is 3 bytes and the first byte(`ef`) is a banned opcode specified in [EIP-3541](https://eips.ethereum.org/EIPS/eip-3541) and the follwing  2 bytes is the 7702 designator.

### Opcode changes

While `CODESIZE` and `CODECOPY` operate on executable code means that they are not impacted.  
Contrary some reading and execution instructions are impacted, including:
  - [EXTCODESIZE](https://www.evm.codes/?fork=cancun#3b) returns 2 bytes
  - [EXTCODEHASH](https://www.evm.codes/?fork=cancun#3f) is the `keccak256` hash of `0xef01`
  - [EXTCODECOPY](https://www.evm.codes/?fork=cancun#3c) returns `0xef01`
  - Exeuction instructions (`CALL`, `CALLCODE`, `STATICCALL`, `DELEGATEACLL`) execute the code from the delegated code address in the context of the EOA

### Gas costs

Each authorization tuple costs 25000 gas, which is calculated by the following formula: `21000 + 16 * non-zero calldata bytes + 4 * zero calldata bytes + 1900 * access list storage key count + 2400 * access list address count`.  
This charges maximum gas upfront and a partial refund of 12500 gas is issued if the contract already exists, which happens through a global refund mechanism.  
The delegated addressed are marked as warm address according to [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929).

### Wallet and UX Changes

[EIP-7821](https://eips.ethereum.org/EIPS/eip-7821) is a proposal to create a batch executor interface for delegations.
The intention of such a proxy contract is that an EIP-7702 transaction delegates to this contract, which points to the wallet implementation of the user. When a user wants to upgrade their wallet they can simple chane the proxy pointer and they don't have to sing another EIP-7702 transaction.
A bundler submits the authorization inside the setcode tx onchain 
Next you have to call "yourself" to init the code. The init data is signed and can been anything e.g. owner, a session key, some delegation, etc.
A lot of 4337's components can and should be reused for 7702 e.g. bundler

## Resources

- [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)
- [EIP-7702 Homepage](https://eip7702.io/)
- [EIP-7702 Discussion](https://ethereum-magicians.org/t/eip-7702-set-eoa-account-code/19923)
- [Decoding 7702](https://medium.com/inception-capital/decoding-vitaliks-eip-7702-507c56f9f70c)
- [EIP-7702: A Deep Dive](https://hackmd.io/@colinlyguo/SyAZWMmr1x)
- [Recommended Proxy Pattern](https://gist.github.com/lightclient/7742e84fde4962f32928c6177eda7523)
- [Awesome EIP-7702](https://github.com/fireblocks-labs/awesome-eip-7702)
- [Great talk about wallet, security, use cases, etc.](https://www.youtube.com/watch?v=TUNtZ5jzXAk)

