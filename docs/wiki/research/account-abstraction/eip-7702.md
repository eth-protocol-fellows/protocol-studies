# EIP-7702: Set EOA code

> :warning: This article is a [stub](https://en.wikipedia.org/wiki/Wikipedia:Stub), help the wiki by [contributing](/contributing.md) and expanding it.

[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)  is a proposal aimed at enhancing Ethereum's account abstraction capabilities. Account abstraction allows for more flexible and programmable account management, enabling features such as multi-signature wallets, social recovery, and gasless transactions. This proposal seeks to improve the user experience and security by decoupling the logic of transaction validation from the underlying account model.

The primary goal of EIP-7702 is to introduce a standardized framework that allows developers to create custom transaction validation logic. A new transaction type (Type 4) is introduced to secure and allow user-friendly wallet solutions, as well as innovative use cases that were previously not possible with the traditional account model. By abstracting the account logic, EIP-7702 aims to reduce the complexity of smart contract interactions and lower the barrier to entry for new users.

With this feature, users can set their address to be represented by a code of an existing smart contract. Type 4 transaction allows address owners to sign an authorization that sets their address to mimic a chosen smart contract.
With this EIP, users can opt in to programmable wallets that allow new features like transaction bundling, gasless transacting and custom asset access for alternative recovery schemes. It's another step towards [account abstraction](https://ethereum.org/en/roadmap/account-abstraction/) that improves user experience and security when interacting with Ethereum.

Review `@lightclient's` technical deep dive:

<!-- markdownlint-disable-next-line MD033 -->
<iframe width="560" height="315" src="https://www.youtube.com/embed/_k5fKlKBWV4?si=Y4DehqLu5fpT7-a3" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Why?

It is also precedeed by ERC-4337, the account abstraction standard.
Given the existence of ERC-4337 you might ask why is EIP-7702 required. The account abstraction has an entirely different goal while this proposal's main goal is to give EOAs some temporary programmability.

The benefits include of programmability are the following:
- Transaction batching
- Transaction Sponsorship
- Privilege de-escalation and Session keys 
- Social Recovery
- And the list is endless...

<!-- TODO 5806 -->
Historically EIP-7702 is a toned-down successor to EIP-3074 which would've added AUTH and AUTHCALL opcodes, but this innitiative didn't make into the protocol.
The main reason for this limited EOA is to push users towards Smart Wallets and create a unified interface froma dApp standpoint.
7702 is a step towards native Account Abstraction and is compatible with Account Abstraction, meaning you can delegate via 7702 to a Smart Wallet.

## Technical Details

In the ethereum account model the difference between contract accounts and externally owned accounts is that EOAs do not have code that can be executed onchain. The code field is set to null as you can see here.
This proposal adds a new EIP-2718 compatible transaction call to set code field for an EOA temporarily.
The EIP-2718 `TransactionType` type is called `SET_CODE_TX_TYPE` with value=4.  
The `SET_CODE_TX_TYPE` transaction has a `TransactionPayload` object defined as a RLP serialized object w/ the following parts:
`chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, value, data, access_list, authorization_list, signature_y_parity, signature_r, signature_s`.
The authorization list is defined as non-empty list of `chain_id, address, nonce, y_parity, r, s` tuple, where the `address` refers to the delegated code's address, the `chain_id` can be set to a valid chain's id or to 0 and the `nonce` has to equal to the EOA for replay protection.
`y_parity, r, s` is the signature of the EOA.  
This list can be submitted by anyone meaning the `tx.origin` doesn't have to be the EOA owner as long as it contains a valid signature. Setting the chain id to zero allows the rerunning of the transaction on any chain, given that the nonce values match.

The transaction receipt is defined as the `status, cumulative_transaction_gas_used, logs_bloom, logs` tuple in RLP seralized form.

You can learn more about RLP encoding in [this section](https://epf.wiki/#/wiki/EL/RLP).

<!-- TODO Add nonce i.e. first check for transaction then for each auth item nonce has to be incremented otherwise fail -->
When such a set code transaction is submitted the following basic steps happen for each tuple in the `authorization_list`.
1. Alongside basic validation(e.g. auth.chain_id < 2^256, auth.nonce < 2^64, etc.) the chain id is verified that it is either 0 or the current chain's id.
2. Then the address of the authority is recovered from the signature and the payload.
3. The code of the authority is either set to `0xef0100 || address` if the `address` is not `0x0000000000000000000000000000000000000000`, otherwise the EOA's code is cleared and is set to the hash of an empty address (`0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`). This acts as a revocation mechanism
4. The addresses are marked as warm address.

This simplified execution steps skipped important steps, a more detailed execution can be found at the [Behavior section](https://eips.ethereum.org/EIPS/eip-7702#behavior) of the EIP.


### creation by template

<!-- TODO Image w/ structure -->
Due to space optimization the traditional `initCode` is replaced by a "code pointer" and the initialization happens during a regular call.
[EIP-3607](https://eips.ethereum.org/EIPS/eip-3607) specifies that an account with deployed code cannot originate transactions.
To work around this the `code` field gets populated with the address of the delegated contract and a prefix which is 23 bytes in total.
The prefix is 3 bytes and the first byte(`ef`) is ...
The next 2 bytes is the 7702 designator.

### Opcode changes

Some reading and execution instructions are impacted by the changes, including:
  - CODESIZE 23 bytes: 20 for code address + 3 bytes of magic prefix `ef0100`, where `ef` comes from EIP-...
  - CODEHASH is the hash of `MAGIC || ADDRESS` and not the hash of the code at `ADDRESS`
  - EXTCODESIZE returns 2
  - EXTCODECOPY returns `0xef01`
  - CALL instruction would execute the code from `address` in the context of the `authority`
  - CALLCODE
  - STATICCALL
  - DELEGATECALL

### Wallet and UX Changes

proxy-contract, a proxy account potentially has multiple "linked" EOAs
The intention of such a proxy contract is that an EIP-7702 transaction delegates to this contract, which points to the wallet implementation of the user. When a user wants to upgrade their wallet they can simple chane the proxy pointer and they don't have to sing another EIP-7702 transaction.
A bundler submits the authorization inside the setcode tx onchain 
Next you have to call "yourself" to init the code. The init data is signed and can been anything e.g. owner, a session key, some delegation, etc.
A lot of 4337's components can and should be reused for 7702 e.g. bundler

### Gas costs

25000 gas/authorization or 12.5k if account already exists
global refund mechanism applies
destination warming

## Resources

- [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)
- [EIP-7702 Homepage](https://eip7702.io/)
- [EIP-7702 Discussion](https://ethereum-magicians.org/t/eip-7702-set-eoa-account-code/19923)
- [Decoding 7702](https://medium.com/inception-capital/decoding-vitaliks-eip-7702-507c56f9f70c)
- [EIP-7702: A Deep Dive](https://hackmd.io/@colinlyguo/SyAZWMmr1x)
- [Recommended Proxy Pattern](https://gist.github.com/lightclient/7742e84fde4962f32928c6177eda7523)
- [Awesome EIP-7702](https://github.com/fireblocks-labs/awesome-eip-7702)
- [Great talk about wallet, security, use cases, etc.](https://www.youtube.com/watch?v=TUNtZ5jzXAk)

